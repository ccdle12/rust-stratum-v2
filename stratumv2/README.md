# stratumv2

This crate contains a library implemenation of the messages and functions
required to build a networked implementation for each component in the Stratum V2
protocol.

## Project Structure


The library has the following structure:

- `benches` - Contains the bench marking tests for the library.

- `nx-noise` - A noise frame work crate generated by [Noise Explorer](https://noiseexplorer.com/).

- `src/common` - This module contains common functions and structs used in all
Stratum V2 sub-protocols.

- `src/job_negotiation` - This module contains functions and structs specific to
ONLY the `job_negotiation` sub-protocol.

- `src/macro_message` - This module contains internal macros to generate
Stratum V2 `Messages` and test macros for `Messages`.

- `src/mining` - This module contains functions and structs specific to
ONLY the `mining` sub-protocol.

- `src/noise` - This module contains functions and structs to enable encrypted
communication using the `Noise Framework` and to validate the certificates of the
`Mining Pool Server`.

- `src/types` - This module contains all the custom types used in Stratum V2.

- `src/error` - Contains the custom error types for this crate.

- `src/frame` - Contains the Traits and functions to de/serialize a `Network Frame`
from and to a Stratum V2 `Message`.

- `src/parse` - Contains the Traits and functions to de/serialize all types and
also contains the de/serialize implementation for all the native types.

## Development

All messages should be constructed using the macro [impl_message](./src/macro_message/message.rs).
The only exceptions are for `Messages` that don't have a [MessageType](./src/types/message_type.rs) such as the messages
found in `src/noise`, since the `noise protocol` is a precursor to subsequent Stratum V2 communication.

Creating a Stratum V2 `Message`:

```rust
use crate::impl_message;

impl_message!(
    /// Struct docstring
    StructName,

    /// Field Docstring
    foo u32,

    /// Field Docstring
    bar u16,
);

impl StructName {
    pub fn new(foo: u32, bar: u16) -> Result<StructName> {
        Ok(StructName { foo, bar })
    }
}
```

## Tests

The current testing strategy takes the approach of heavily unit testing the
smallest types in the library. By relying on the smallest types being tested,
we assert that when those types are used to construct larger types, all the
components in a larger type are correct.

- All the native types such as `u8, u16, u32 etc...` and custom types such as
`B0_255` and `B0_32` have been heavily tested to assert that they will
de/serialize correctly according to the Stratum V2 spec.

- Stratum V2 `Messages` are constructed using only these native and custom types.
We don't need to test the de/serialization of the individual fields. Instead,
we can test the rules around de/serializing the `Messages` as well as any other
cases at this level.

Testing a `Message` should use the macro [impl_message_tests](./src/macro_message/message.rs).
This macro will generate the standard tests for a Stratum V2 `Message`.

Testing a Stratum V2 `Message`:

```rust
use crate::impl_message;

impl_message!(
    /// Struct docstring
    StructName,

    /// Field Docstring
    foo u32,

    /// Field Docstring
    bar u16,
);

impl StructName {
    pub fn new(foo: u32, bar: u16) -> Result<StructName> {
        Ok(StructName { foo, bar })
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::impl_message_tests;

    fn expected_deserialized_state() -> StructName {
        StructName::new(1u32, 1u16).unwrap()
    }

    fn expected_serialized_state() -> Vec<u8> {
        return vec![
            0x01, 0x00, 0x00, 0x00,
            0x01, 0x00,
        ];
    }

    impl_message_tests!(
        StructName,
        expected_deserialized_state,
        expected_serialized_state,
    );
}

```

## Benchmarking

To run the benchmarking tests, run the following command:

```
cargo bench
```
